* AMDAHL'S LAW
** FORMULA
[[images/amdahls_law/amdahls_law.svg]]
** LaTeX
#+begin_src   
\[S_{latency(s)} = \frac{1}{1 - p + \frac{p}{s}}\]
#+end_src
** VARIABLES
| Variable Name                    | Variable Description                                                                              |
| [[images/amdahls_law/s_latency.svg]] | Overall, theoretical speedup of the entire task by the improvement                                |
| [[images/amdahls_law/p.svg]]         | Proportion of execution time that the part benefiting from improved resources originally occupied |
| [[images/amdahls_law/s.svg]]        | speedup of the part of the task that benefits from improved system resources                      |
|                                  |                                                                                                   |
** NOTES
A formula to work out the theoretical speedup of an entire task by improving only a part of the code or system.
This law states that the overall performance improvement gained by optimising a single part of a system is limited by the fraction of time that the improved part is actually used.
** EXAMPLE
A system part initially consumes 60% of execution time (p = 0.6). The part is sped up by a factor of 3 (s = 3)

[[images/amdahls_law/example_1.svg]]

[[images/amdahls_law/example_2.svg]]

or

[[images/amdahls_law/example_3.svg]]

Notice that a significant increase to the speed of a part led to a much more modest increase in overall system performance.
** EXAMPLE LaTeX
#+begin_src   
\[speedup = \frac{1}{1 - p + \frac{p}{s}}\]
#+end_src
#+begin_src   
\[1 \div (1 - 0.6 + (0.6 \div3)) = 1.66666666667\]
#+end_src
#+begin_src   
\[speedup = \frac{1}{1 - 0.6 + \frac{0.6}{3}} = 1.66666666667\]
#+end_src
** LINKS
| Link       |
| [[https://en.wikipedia.org/wiki/Amdahl%27s_law][Wikipedia]]  |
| [[https://www.techopedia.com/definition/17035/amdahls-law][Techopedia]] |
| [[https://www.vcalc.com/wiki/vCalc/Amdahl%27s+Law][Calculator]] |
** PROGRAMMING LANGUAGES
*** C
#+begin_src c   
double amdahls_law_ratio(double p, double s){
  return 1 / (1 - p + p/s);
}

double amdahls_law_percentage(double p, double s){
  return 1 / (1 - (p/100) + (p/100)/s);
}
#+end_src
*** C++17
#+begin_src C++   
auto amdahls_law_ratio = [](double p, double s){return 1 / (1 - p + p/s);};

auto amdahls_law_percentage = [](double p, double s){return 1 / (1 - (p/100) + (p/100)/s);};
#+end_src
*** CLOJURE
#+begin_src clojure   
(defn amdahls_law_ratio [p s]
  (/ 1.0 (+  1.0 (- p) (/ p s))))

(defn amdahls_law_percentage [p s]
  (/ 1.0 (+  1.0 (- (/ p 100.0)) (/ (/ p 100.0) s))))
#+end_src
*** COMMON LISP
#+begin_src lisp   
(defun amdahls-law-ratio(p s)
  (/ 1.0 (+ 1.0 (- p)(/ p s))))

(defun amdahls-law-percentage(p s)
  (/ 1.0 ( + 1.0 (- (/ p 100.0)) (/ (/ p 100.0) s))))
#+end_src
*** HASKELL
#+begin_src haskell  
amdahls_law_ratio :: Double -> Double -> Double
amdahls_law_ratio p s = 1 / (1 - p + p/s) 

amdahls_law_percentage :: Double -> Double -> Double
amdahls_law_percentage p s = 1 / (1 - (p/100) + (p/100) / s)
#+end_src
*** JAVASCRIPT
#+begin_src javascript  
const amdahls_law_ratio = (p, s) => 1 / (1 - p + p/s);
    
const amdahls_law_percentage = (p, s) => 1 / (1 - (p/100) + (p/100) / s);
#+end_src
*** PYTHON
#+begin_src python   
amdahls_law_ratio = lambda p, s : 1 / (1 - p + p / s)
    
amdahls_law_percentage = lambda p, s : 1 / (1 - (p/100) + (p/100) / s)
#+end_src
*** TYPESCRIPT
#+begin_src typescript  
const amdahls_law_ratio = (p: number, s: number): number => 1 / (1 - p + p/s);
    
const amdahls_law_percentage = (p: number, s: number): number => 1 / (1 - (p/100) + (p/100) / s);
#+end_src
** GRAPHS
[[images/amdahls_law/graph_1.png]]
[[images/amdahls_law/graph_2.png]]
*** GRAPH PYTHON
#+begin_src python  
import numpy as np
import csv
import matplotlib.pyplot as plt

my_range = np.linspace(0,100,100)

amdahls_law = lambda p, s : 1 / (1 - (p/100) + (p/100) / s)

plot_factor = lambda my_range, factor:  plt.plot(amdahls_law(my_range, factor), my_range, label = "(s) Part sped up by a factor of " + str(factor))

plot_factor(my_range, 2)
plot_factor(my_range, 3)
plot_factor(my_range, 4)

plt.title('Amdahls Law')
plt.xlabel('(SLatency): Total Improvement of system')
plt.ylabel('(P): % of time the part previously occupied')
plt.grid(color='black', linestyle='-', linewidth=0.5)
plt.legend()
plt.show()
#+end_src
#+begin_src python  
import numpy as np
import csv
import matplotlib.pyplot as plt

my_range = np.linspace(0,10,100)

amdahls_law = lambda p, s : 1 / (1 - (p/100) + (p/100) / s)

plot_percentage = lambda percentage, my_range: plt.plot(my_range, amdahls_law(percentage, my_range), label = "(p): part previously  occupied " + str(percentage) + "% of time") 

plot_percentage(25, my_range)
plot_percentage(50, my_range)
plot_percentage(75, my_range)

plt.title('Amdahls Law')
plt.xlabel('(s): Part sped up by a factor of')
plt.ylabel('(SLatency): Total Improvement of system')
plt.grid(color='black', linestyle='-', linewidth=0.5)
plt.legend()
plt.show()
#+end_src

** TRIVIA
Sometimes called Amdahl's argument.

named after computer scientist Gene Amdahl.

Was presented at the AFIPS Spring Joint Computer Conference in 1967.

Often used in parallel computing to predict the theoretical speedup when using multiple processors.

